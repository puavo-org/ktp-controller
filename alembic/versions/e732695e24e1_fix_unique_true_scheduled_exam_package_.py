"""Fix scheduled_exam_package.current unique true value column

Revision ID: e732695e24e1
Revises: cf3a53e8cfbd
Create Date: 2025-12-15 21:48:13.234660

"""

from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa

# Revision identifiers (auto-generated by Alembic)
revision: str = "e732695e24e1"
down_revision: Union[str, Sequence[str], None] = "cf3a53e8cfbd"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade():
    ## SQLite mambo jambo begins. SQLite has quite lacking ALTER TABLE
    ## implementation and here we are trying to circumvent its
    ## shortcomings. So, what we are trying to achieve: make
    ## scheduled_exam_package.current not UNIQUE and not NULLable.
    ##
    ## First, we remove UNIQUE constraint from it by re-creating the
    ## table without UNIQUE, and copying data from the original table to it
    ## and then renaming it back to the original name.
    ##
    ## Second, we ensure existing data does not have NULLs (they get
    ## replaced with false) before setting
    ## scheduled_exam_package.current to NOT NULL.
    ##
    ## Third, we add unique index which ensures
    ## scheduled_exam_package.current column can never have more than
    ## one true value. In this step, we also add check constraint
    ## which ensures scheduled_exam_package.current can only be either
    ## 0 or 1.

    conn = op.get_bind()
    conn.execute(sa.text("PRAGMA foreign_keys=OFF"))

    conn.execute(sa.text("ALTER TABLE scheduled_exam_package RENAME TO original"))
    conn.execute(
        sa.text(
            """
CREATE TABLE step1 (
        dbid INTEGER NOT NULL,
        dbrow_created_at DATETIME NOT NULL,
        external_id VARCHAR NOT NULL,
        start_time DATETIME NOT NULL,
        end_time DATETIME NOT NULL,
        lock_time DATETIME,
        locked BOOLEAN NOT NULL,
        current BOOLEAN,
        state VARCHAR,
        state_changed_at DATETIME,
        PRIMARY KEY (dbid)
)"""
        )
    )
    conn.execute(sa.text("INSERT INTO step1 SELECT * FROM original"))
    conn.execute(sa.text("DROP TABLE original"))

    conn.execute(sa.text("UPDATE step1 SET current = false WHERE current IS NULL"))

    conn.execute(
        sa.text(
            """
CREATE TABLE step2 (
        dbid INTEGER NOT NULL,
        dbrow_created_at DATETIME NOT NULL,
        external_id VARCHAR NOT NULL,
        start_time DATETIME NOT NULL,
        end_time DATETIME NOT NULL,
        lock_time DATETIME,
        locked BOOLEAN NOT NULL,
        current BOOLEAN NOT NULL CHECK (current IN (0, 1)),
        state VARCHAR,
        state_changed_at DATETIME,
        PRIMARY KEY (dbid)
)"""
        )
    )
    conn.execute(sa.text("INSERT INTO step2 SELECT * FROM step1"))
    conn.execute(sa.text("DROP TABLE step1"))

    # Because the table was renamed to "original', all foreign keys still
    # reference "original". Here we rename the table once again, back and
    # forth, to re-update foreign key refs.
    conn.execute(sa.text("ALTER TABLE step2 RENAME TO scheduled_exam_package"))
    conn.execute(sa.text("ALTER TABLE scheduled_exam_package RENAME TO original"))
    conn.execute(sa.text("ALTER TABLE original RENAME TO scheduled_exam_package"))

    # This index ensures there can be never more than one true value in scheduled_exam_package.current column
    conn.execute(
        sa.text(
            "CREATE UNIQUE INDEX ix_scheduled_exam_package_current ON scheduled_exam_package (current) WHERE current = 1"
        )
    )

    # Re-create indexes which got removed because the original table was dropped.
    conn.execute(
        sa.text(
            "CREATE INDEX ix_scheduled_exam_package_dbrow_created_at ON scheduled_exam_package (dbrow_created_at)"
        )
    )
    conn.execute(
        sa.text(
            "CREATE UNIQUE INDEX ix_scheduled_exam_package_external_id ON scheduled_exam_package (external_id)"
        )
    )

    conn.execute(sa.text("PRAGMA foreign_keys=ON"))


def downgrade():
    raise RuntimeError(
        "downgrade not supported because it is non-trivial and the developer thought that it's not worth the effort"
    )
