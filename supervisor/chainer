#!/usr/bin/env python3
import json
import os
import subprocess
import sys


def write_stdout(s):
    # only eventlistener protocol messages may be sent to stdout
    sys.stdout.write(s)
    sys.stdout.flush()


def write_stderr(s):
    sys.stderr.write(s)
    sys.stderr.flush()


def _supervisorctl(command, conf_filename, *args):
    with open(os.devnull, "wb") as devnull:
        subprocess.check_call(
            ["supervisorctl", "-c", os.path.join("supervisor", conf_filename), command]
            + list(args),
            stdout=devnull,
        )


def main():
    last_processname = sys.argv[1]
    conf_filename = sys.argv[2]

    try:
        os.unlink("supervisor/chain_result")
    except FileNotFoundError:
        pass
    while 1:
        # transition from ACKNOWLEDGED to READY
        write_stdout("READY\n")

        # read header line and print it to stderr
        header_line = sys.stdin.readline()

        # read event payload and print it to stderr
        headers = dict([x.split(":") for x in header_line.split()])
        write_stderr(json.dumps(headers))
        write_stderr("\n")

        payload_data = sys.stdin.read(int(headers["len"]))
        payload = dict([x.split(":") for x in payload_data.split()])
        write_stderr(json.dumps(payload))
        write_stderr("\n")

        if (
            headers["eventname"] == "PROCESS_STATE_EXITED"
            and payload["processname"] == "docker-pull"
        ):
            _supervisorctl("start", conf_filename, "redis")
        elif (
            headers["eventname"] == "PROCESS_STATE_RUNNING"
            and payload["processname"] == "redis"
        ):
            _supervisorctl("start", conf_filename, last_processname)
        elif (
            headers["eventname"]
            in ("PROCESS_STATE_EXITED", "PROCESS_STATE_STOPPED", "PROCESS_STATE_FATAL")
            and payload["processname"] == last_processname
        ):
            if headers["eventname"] == "PROCESS_STATE_EXITED" and bool(
                payload["expected"]
            ):
                result = "ok"
            else:
                result = "fail"
            with open("supervisor/chain_result.tmp", "wb") as f:
                f.write(f"{result}\n".encode("ascii"))
            os.rename("supervisor/chain_result.tmp", "supervisor/chain_result")

            _supervisorctl("shutdown", conf_filename)

        # transition from READY to ACKNOWLEDGED
        write_stdout("RESULT 2\nOK")


if __name__ == "__main__":
    try:
        main()
    except Exception as e:  # pylint: disable=broad-exception-caught
        write_stderr(str(e))
        write_stdout("RESULT 4\nFAIL")
