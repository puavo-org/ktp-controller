#!/usr/bin/env python3
import json
import os
import subprocess
import sys


def write_stdout(s):
    # only eventlistener protocol messages may be sent to stdout
    sys.stdout.write(s)
    sys.stdout.flush()


def write_stderr(s):
    sys.stderr.write(s)
    sys.stderr.flush()


def _supervisorctl(command, conf_filename, *args):
    with open(os.devnull, "wb") as devnull:
        subprocess.check_call(
            ["supervisorctl", "-c", os.path.join("supervisor", conf_filename), command]
            + list(args),
            stdout=devnull,
        )


def main():
    conf_filename = sys.argv[1]
    processnames = sys.argv[2:]
    started_processnames = set()
    waited_processname = ""
    try:
        os.unlink("supervisor/chain_result")
    except FileNotFoundError:
        pass
    while 1:
        # transition from ACKNOWLEDGED to READY
        write_stdout("READY\n")

        # read header line and print it to stderr
        header_line = sys.stdin.readline()

        # read event payload and print it to stderr
        headers = dict([x.split(":") for x in header_line.split()])
        write_stderr(json.dumps(headers))
        write_stderr("\n")

        payload_data = sys.stdin.read(int(headers["len"]))
        payload = dict([x.split(":") for x in payload_data.split()])
        write_stderr(json.dumps(payload))
        write_stderr("\n")

        try:
            i = processnames.index(payload["processname"])
        except ValueError:
            write_stdout("RESULT 2\nOK")
            continue

        if waited_processname:
            if waited_processname == payload["processname"] and headers[
                "eventname"
            ] in (
                "PROCESS_STATE_EXITED",
                "PROCESS_STATE_STOPPED",
                "PROCESS_STATE_FATAL",
            ):
                waited_processname = ""
            else:
                write_stdout("RESULT 2\nOK")
                continue

        is_last = i == len(processnames) - 1

        if not is_last:
            next_processname = processnames[i + 1]
            if next_processname == "WAIT":
                processnames.pop(i + 1)
                waited_processname = payload["processname"]
            elif next_processname not in started_processnames:
                _supervisorctl("start", conf_filename, next_processname)
                started_processnames.add(next_processname)
        elif headers["eventname"] in (
            "PROCESS_STATE_EXITED",
            "PROCESS_STATE_STOPPED",
            "PROCESS_STATE_FATAL",
        ):
            if headers["eventname"] == "PROCESS_STATE_EXITED" and bool(
                int(payload["expected"])
            ):
                result = "ok"
            else:
                result = "fail"
            with open("supervisor/chain_result.tmp", "wb") as f:
                f.write(f"{result}\n".encode("ascii"))
            os.rename("supervisor/chain_result.tmp", "supervisor/chain_result")

            _supervisorctl("shutdown", conf_filename)

        # transition from READY to ACKNOWLEDGED
        write_stdout("RESULT 2\nOK")


if __name__ == "__main__":
    try:
        main()
    except Exception as e:  # pylint: disable=broad-exception-caught
        write_stderr(str(e))
        write_stdout("RESULT 4\nFAIL")
